## Discarding local changes (git restore, git checkout)

There will be times when you need to reset your working directory to a clean state. Whether it's due to mistakes or a need to abandon changes, Git provides several commands to help you manage this cleanup.

One of the primary commands you'll use is git restore. This command was introduced as a cleaner and safer alternative to git reset, and it can be applied to both your working directory and staging area.

To discard changes in your working directory, you can run:

```sh
git restore .
```

This command will revert all modified and deleted files in the working directory to their last committed state. However, it will not affect the staging area—the zone where changes are prepared for committing.

If you only want to **unstage** files (i.e., move them from the staging area back to the working directory), use:

```sh
git restore --staged .
```

To restore all files in both the staging area and the working directory to their state in the last commit, run:

```sh
git restore --source=HEAD --staged --worktree .
```

Sometimes, you might accidentally delete a file and want to restore it. You can easily retrieve the file from the latest commit using:

### Why using restore

You can choose to restore file that you previously deleted while still needing them in fact

```sh
git restore --source=HEAD <deleted-file>
```

> Remember, HEAD is a pointer to the latest commit on the active branch. By plaging with it you are able to move through commits history and thus project version.

> If you deleted a file but didn’t commit that deletion, git restore will bring back the file from the last commit, but if you already committed the deletion, you'd need to use git restore as described or recover from other commits where the file existed.

## Unstaging files (git reset HEAD)

## Amending commits (git commit --amend)

## Reverting commits (git revert)

## Reset vs. Revert vs. Checkout
